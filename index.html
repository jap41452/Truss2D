<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Truss — Draw • Solve • Reactions • Stresses</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

<style>
  :root { --pad:18px; --canvas-w:900px; --canvas-h:560px; --panel-w:340px; }
  body { background:#f6f7fb; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:20px; }
  h2 { margin:0 0 10px; }
  .row { display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }
  .col { background:#fff; border:1px solid #ddd; border-radius:12px; padding:var(--pad); }
  .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:10px; }
  .controls.split { justify-content:flex-start; }
  button, select, input[type="number"], input[type="text"]{
    height:32px; padding:0 10px; border:1px solid #bbb; border-radius:8px; background:#eee; font-size:14px; color:#333;
  }
  input[type="range"]{ width:120px; }
  button { cursor:pointer; transition:background 0.15s ease, color 0.15s ease, border-color 0.15s ease; }
  button.primary { background:#eee; color:#333; border-color:#bbb; }
  button.ghost   { background:#eee; color:#333; border-color:#bbb; }
  /* Grayed-out look for active/selected buttons */
  button.active  { background:#cfd8e3; color:#555; border-color:#9aa6b2; box-shadow: inset 0 0 0 1px #9aa6b2; cursor:default; }

  .labelbtn { pointer-events:none; opacity:1; font-weight:600; }

  .stack { display:flex; flex-direction:column; gap:8px; }
  #wrap { position:relative; width:var(--canvas-w); height:var(--canvas-h); background:#fff; border:1px solid #ccc; border-radius:8px; }
  canvas { position:absolute; inset:0; }
  #base { z-index:1; } #overlay { z-index:2; pointer-events:auto; cursor:crosshair; }

  .panel { width:var(--panel-w); }
  .list { font-size:13px; max-height:240px; overflow:auto; border:1px dashed #ddd; padding:8px; border-radius:8px; }
  .hint { color:#666; font-size:12px; }
  .swal2-popup { font-size:12px !important; width:auto !important; min-width:360px !important; }
  .swal2-input, .swal2-select { font-size:12px !important; height:28px !important; }

  /* Node panel inputs */
  .node-row { display:grid; grid-template-columns: 54px 1fr 1fr 28px; gap:6px; align-items:center; }
  .node-row > .badge { justify-self:start; font-weight:600; color:#334155; }
  .node-row input[type="number"]{ width:100%; height:28px; padding:0 6px; border-radius:6px; }
  .node-row button { height:28px; padding:0 8px; }

  #stressPanelBlock { display:none; }
  #stressPanel { width:100%; height:260px; position:static; border:1px solid #ccc; border-radius:8px; }
</style>
</head>

<body>
  <h2>TRUSS</h2>

  <!-- TOP ROW -->
  <div class="controls split" id="rowTop">
    <button id="btnDraw"   class="primary">Draw Members</button>
    <button id="btnSelect" class="ghost">Select/Edit</button>

    <button id="viewGeom" class="ghost">Geometry</button>

    <button id="btnUndo"  class="ghost">Undo</button>
    <button id="btnClear" class="ghost">Clear</button>

    <span class="hint" style="margin-left:6px;">
      Draw: drag to add a member. Select: drag a node to move; double-click to edit; Delete key removes.
    </span>
  </div>

  <div class="row">
    <div class="col">
      <div id="wrap">
        <canvas id="base"    width="980" height="560"></canvas>
        <canvas id="overlay" width="980" height="560"></canvas>
      </div>

      <!-- BOTTOM ROW -->
      <div class="controls split" style="margin-top:10px; gap:12px;">
        <button class="ghost labelbtn" disabled>Segment Divisions</button>
        <input id="divCount"  type="number" min="1" max="50" value="10" style="width:80px;">

        <button id="btnSolve" class="primary">Solve</button>
        <button id="viewDef"  class="ghost">Deflections</button>
        <button id="viewStressPanel" class="ghost">Stresses</button>

        <button class="ghost labelbtn" disabled>Deflection Scale</button>
        <input id="defScale"  type="number" step="any" value="1" style="width:80px;">

        <!-- Animate -->
        <button id="btnAnimate" class="ghost">Animate</button>
        <label class="ghost labelbtn" style="margin-left:6px;" disabled>Freq (Hz)</label>
        <input id="animFreq" type="range" min="0.2" max="3" step="0.1" value="1.2">
        <span id="animFreqVal" class="hint">1.2</span>

        <!-- Save/Load inputs -->
        <button id="btnSaveInput" class="ghost">Save Input</button>
        <button id="btnLoadInput" class="ghost">Load Input</button>
        <input id="fileInput" type="file" accept=".json,application/json" style="display:none;">

        <button id="btnExportCSV" class="ghost">Export Nodal CSV</button>
        <button id="btnExportStressCSV" class="ghost">Export Stresses CSV</button>

        <button id="btnResetView" class="ghost">Reset Results</button>
      </div>
    </div>

    <div class="col panel stack">
      <div>
        <div><strong>Units (display only)</strong></div>
        <div class="controls">
          <button id="btnUS" class="ghost">US (in, lbs)</button>
          <button id="btnSI" class="ghost">SI (m, N)</button>
        </div>
        <div class="hint">Solver is unit-agnostic; keep inputs consistent.</div>
      </div>

      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <strong>Nodes (editable)</strong>
          <span class="hint">Edit X/Y to move nodes</span>
        </div>
        <div id="nodeList" class="list"></div>
      </div>

      <div>
        <div><strong>Members</strong></div>
        <div id="memberList" class="list"></div>
      </div>

      <div>
        <div><strong>Results (primary nodes)</strong></div>
        <div id="resultList" class="list"></div>
      </div>

      <!-- Stress Panel docked in sidebar -->
      <div id="stressPanelBlock">
        <div class="controls" style="justify-content:space-between;">
          <strong>Stress Panel</strong>
          <button id="btnCloseStressPanel" class="ghost">Close</button>
        </div>
        <canvas id="stressPanel"></canvas>
        <div id="stressPanelHint" class="hint" style="margin-top:6px;">
          Click a member (while this view is active) to plot σ<sub>L</sub> (red) & σ<sub>R</sub> (blue) vs length.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas & State =====
  const base = document.getElementById('base');
  const overlay = document.getElementById('overlay');
  const stressCanvas = document.getElementById('stressPanel');
  const stressBlock  = document.getElementById('stressPanelBlock');
  const ctx = base.getContext('2d');
  const ovr = overlay.getContext('2d');
  const spx = stressCanvas.getContext('2d');

  const nodeList   = document.getElementById('nodeList');
  const memberList = document.getElementById('memberList');
  const resultList = document.getElementById('resultList');

  const MAX_MEMBERS = 50;
  let mode = 'draw';        // 'draw' | 'select'
  let viewMode = 'geom';    // 'geom' | 'def' | 'stresspanel'
  let units = 'US';         // display only

  // Truss nodes: {id,x,y, bc, Fx,Fy, Kx,Ky}
  let nodes = [];
  // Members: {id,n1,n2,E,A,I,S,c,wd,qix,qjx,qiy,qjy,label}
  let members = [];
  let nextNodeId = 1, nextMemberId = 1;

  let dragStart = null, hoverEndNodeId = null;
  let lastSolution = null;
  let selectedMemberId = null;
  let selectedNodeId = null;
  let selectedMemberForDelete = null;
  let movingNodeId = null;
  let moveOffset = {dx:0, dy:0};

  // Animation state
  let anim = { on:false, t0:0, raf:null, scaleOverride:null };
  const animFreq = document.getElementById('animFreq');
  const animFreqVal = document.getElementById('animFreqVal');

  // Hover tooltip
  let hoverInfo = null; // {x,y, lines:[...]} in screen coords

  // ===== Helpers =====
  const dist2 = (a,b,x,y) => (a-x)*(a-x)+(b-y)*(b-y);
  const nearNodeId = (x,y, tol=9) => {
    let best=null, dmin=tol*tol;
    for (const n of nodes) { const d=dist2(n.x,n.y,x,y); if (d<=dmin){best=n; dmin=d;} }
    return best?best.id:null;
  };
  const nodeById   = id => nodes.find(n=>n.id===id);
  const memberById = id => members.find(m=>m.id===id);

  const pointToSegmentProjectionT = (P, A, B) => {
    const ABx=B.x-A.x, ABy=B.y-A.y, APx=P.x-A.x, APy=P.y-A.y;
    const ab2 = ABx*ABx + ABy*ABy || 1e-9;
    let t = (APx*ABx + APy*ABy)/ab2; return Math.max(0,Math.min(1,t));
  };
  const pointToSegmentDistance = (P, A, B) => {
    const t = pointToSegmentProjectionT(P,A,B);
    const Cx=A.x+t*(B.x-A.x), Cy=A.y+t*(B.y-A.y);
    return Math.hypot(P.x-Cx, P.y-Cy);
  };
  const nearMemberId = (x,y, tol=6) => {
    let bestId=null, best=tol;
    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      const d=pointToSegmentDistance({x,y},a,b);
      if (d<best){best=d; bestId=m.id;}
    }
    return bestId;
  };

  function addNode(x,y){
    const id=nextNodeId++;
    nodes.push({id,x,y,bc:'free',Fx:0,Fy:0,Kx:0,Ky:0});
    refreshLists();
    return id;
  }
  function addMember(n1,n2){
    if (members.length>=MAX_MEMBERS){ Swal.fire('Limit reached','Max members reached for now.','info'); return null; }
    const id=nextMemberId++;
    // carry forward last props
    let E=0,A=0,I=0,S=0,c=0,wd=0,qix=0,qjx=0,qiy=0,qjy=0,label=`M${id}`;
    if (members.length>=1){
      const t = members[members.length-1];
      ({E,A,I,S,c,wd,qix,qjx,qiy,qjy} = t);
    }
    members.push({ id,n1,n2,E,A,I,S,c,wd,qix,qjx,qiy,qjy,label });
    refreshLists();
    return id;
  }
  function deleteMember(id){
    const idx = members.findIndex(m=>m.id===id);
    if (idx<0) return;
    members.splice(idx,1);
    lastSolution = null;
    if (selectedMemberId===id) selectedMemberId=null;
    if (selectedMemberForDelete===id) selectedMemberForDelete=null;
    refreshLists(); draw();
  }
  function deleteNodeWithMembers(nodeId){
    const nidx = nodes.findIndex(n=>n.id===nodeId);
    if (nidx<0) return;
    members = members.filter(m => m.n1!==nodeId && m.n2!==nodeId);
    nodes.splice(nidx,1);
    lastSolution = null;
    if (selectedNodeId===nodeId) selectedNodeId=null;
    refreshLists(); draw();
  }

  const yUp     = yCanvas => base.height - yCanvas;
  const yCanvas = yUpVal  => base.height - yUpVal;

  // ===== Active button helpers =====
  const modeBtns = ['btnDraw','btnSelect'];
  const viewBtns = ['viewGeom','viewDef','viewStressPanel'];
  function setActiveGroup(ids, activeId){
    ids.forEach(id => {
      const el = document.getElementById(id);
      el.classList.toggle('active', id===activeId);
    });
  }

  // ===== UI Buttons =====
  document.getElementById('btnDraw').onclick   = () => { mode='draw';   overlay.style.cursor='crosshair'; setActiveGroup(modeBtns,'btnDraw'); draw(); };
  document.getElementById('btnSelect').onclick = () => { mode='select'; overlay.style.cursor='pointer';   setActiveGroup(modeBtns,'btnSelect'); draw(); };

  document.getElementById('viewGeom').onclick = ()=>{ stopAnim(); viewMode='geom'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewGeom'); draw(); };
  document.getElementById('viewDef').onclick  = ()=>{ stopAnim(); viewMode='def';  toggleStressPanel(false); setActiveGroup(viewBtns,'viewDef');  draw(); };
  document.getElementById('viewStressPanel').onclick = ()=>{ stopAnim(); viewMode='stresspanel'; toggleStressPanel(true); setActiveGroup(viewBtns,'viewStressPanel'); draw(); };
  document.getElementById('btnCloseStressPanel').onclick = ()=>{ stopAnim(); viewMode='geom'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewGeom'); draw(); };

  document.getElementById('btnUndo').onclick = () => {
    stopAnim(); lastSolution=null;
    if (dragStart){ dragStart=null; hoverEndNodeId=null; draw(); return; }
    if (members.length){ members.pop(); refreshLists(); draw(); return; }
    if (nodes.length){ nodes.pop(); refreshLists(); draw(); return; }
  };
  document.getElementById('btnClear').onclick = () => {
    stopAnim();
    nodes=[]; members=[]; nextNodeId=1; nextMemberId=1; lastSolution=null;
    selectedNodeId=null; selectedMemberForDelete=null; selectedMemberId=null;
    viewMode='geom'; toggleStressPanel(false);
    setActiveGroup(modeBtns,'btnDraw'); setActiveGroup(viewBtns,'viewGeom');
    refreshLists(); draw();
  };

  // Save / Load Inputs
  document.getElementById('btnSaveInput').onclick = () => {
    const data={units,nodes,members};
    const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='truss_input.json'; a.click();
    URL.revokeObjectURL(url);
  };
  const fileInput = document.getElementById('fileInput');
  document.getElementById('btnLoadInput').onclick = () => fileInput.click();
  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files[0]; if (!f) return;
    const rd = new FileReader();
    rd.onload = () => {
      try{
        const obj = JSON.parse(rd.result);
        if (!obj.nodes || !obj.members) throw new Error('Missing nodes/members arrays');
        nodes = obj.nodes.map(n=>({
          id:n.id, x:n.x, y:n.y, bc:n.bc||'free',
          Fx:n.Fx||0, Fy:n.Fy||0, Kx:n.Kx||0, Ky:n.Ky||0
        }));
        members = obj.members.map(m=>({
          id:m.id, n1:m.n1, n2:m.n2, E:m.E||0, A:m.A||0,
          I:m.I||0, S:m.S||0, c:m.c||0, wd:m.wd||0,
          qix:m.qix||0, qjx:m.qjx||0, qiy:m.qiy||0, qjy:m.qjy||0,
          label:m.label||`M${m.id}`
        }));
        nextNodeId = (nodes.reduce((a,n)=>Math.max(a,n.id),0) || 0) + 1;
        nextMemberId = (members.reduce((a,m)=>Math.max(a,m.id),0) || 0) + 1;
        lastSolution=null; selectedNodeId=null; selectedMemberId=null; selectedMemberForDelete=null;
        refreshLists(); draw();
        Swal.fire('Loaded','Input model loaded. Click Solve to run.','success');
      }catch(err){
        console.error(err);
        Swal.fire('Load failed','Could not parse this JSON input.','error');
      }
      fileInput.value='';
    };
    rd.readAsText(f);
  });

  // Results export
  document.getElementById('btnExportCSV').onclick = () => {
    if (!lastSolution || !lastSolution.primaryRes){
      Swal.fire('Note','Solve first to export results.','info'); return;
    }
    const rows=[['node','ux','uy']];
    lastSolution.primaryRes.forEach(r => rows.push([r.id,r.ux,r.uy]));
    const csv = rows.map(r=>r.join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'truss_nodal_results.csv'; a.click();
    URL.revokeObjectURL(a.href);
  };

  // Export Stresses CSV
  document.getElementById('btnExportStressCSV').onclick = () => {
    if (!lastSolution || !lastSolution.stress){
      Swal.fire('Note','Solve first, then export stresses.','info'); return;
    }
    const stress = lastSolution.stress;
    const rows = [['member','sample','x_along','sigma_L','sigma_R']];
    for (const memId of Object.keys(stress)) {
      const st = stress[memId];
      if (!st || !st.pts || st.pts.length===0) continue;
      const xs=[0]; let Lsum=0;
      for (let i=1;i<st.pts.length;i++){
        const x0=st.pts[i-1].x_up, y0=st.pts[i-1].y_up, x1=st.pts[i].x_up, y1=st.pts[i].y_up;
        Lsum += Math.hypot(x1-x0, y1-y0);
        xs.push(Lsum);
      }
      for (let k=0;k<st.sL.length;k++){
        rows.push([memId, k, xs[k], st.sL[k], st.sR[k]]);
      }
    }
    const csv = rows.map(r=>r.join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'truss_member_stresses.csv';
    a.click();
    URL.revokeObjectURL(a.href);
  };

  document.getElementById('btnUS').onclick = () => { units='US'; Swal.fire('Units set','US (in, lbs)','success'); };
  document.getElementById('btnSI').onclick = () => { units='SI'; Swal.fire('Units set','SI (m, N)','success'); };

  document.getElementById('btnSolve').onclick = () => { stopAnim(); solveTruss(); };
  document.getElementById('btnResetView').onclick = () => { stopAnim(); lastSolution=null; selectedMemberId=null; draw(); };

  // Animate controls
  document.getElementById('btnAnimate').onclick = () => { if (anim.on) stopAnim(); else startAnim(); };
  animFreq.addEventListener('input', () => { animFreqVal.textContent = animFreq.value; });

  function startAnim(){
    if (anim.on) return;
    anim.on = true; anim.t0 = 0;
    const btn = document.getElementById('btnAnimate');
    btn.textContent = 'Stop';
    btn.classList.add('active'); // gray while active
    const tick = (ts)=>{
      if (!anim.on){ anim.raf=null; return; }
      if (!anim.t0) anim.t0 = ts;
      const t = (ts - anim.t0) / 1000;
      const f = parseFloat(document.getElementById('animFreq').value) || 1;
      const base = parseFloat(document.getElementById('defScale').value) || 1;
      const amp = 0.5 * (1 - Math.cos(2*Math.PI*f*t));
      anim.scaleOverride = base * amp;
      if (viewMode === 'def') draw();
      anim.raf = requestAnimationFrame(tick);
    };
    anim.raf = requestAnimationFrame(tick);
  }
  function stopAnim(){
    if (!anim.on) return;
    anim.on = false; anim.scaleOverride = null;
    if (anim.raf){ cancelAnimationFrame(anim.raf); anim.raf=null; }
    if (viewMode === 'def') draw();
    const btn = document.getElementById('btnAnimate');
    btn.textContent = 'Animate';
    btn.classList.remove('active');
  }

  // ===== Overlay Events =====
  overlay.addEventListener('mousedown', (e)=>{
    hoverInfo = null;
    const {x,y}=mousePos(e);
    if (mode==='draw'){
      const nid=nearNodeId(x,y);
      let startNode, created=false, existing=false;
      if (nid){ startNode=nodeById(nid); existing=true; }
      else { const id=addNode(x,y); startNode=nodeById(id); created=true; }
      dragStart={x:startNode.x, y:startNode.y, nodeId:startNode.id, createdStart:created, existingStart:existing};
      hoverEndNodeId=null;
    } else if (mode==='select'){
      const nid = nearNodeId(x,y,8);
      if (nid){
        const n = nodeById(nid);
        movingNodeId = nid;
        moveOffset.dx = x - n.x;
        moveOffset.dy = y - n.y;
        selectedNodeId = nid;
        selectedMemberForDelete = null;
        overlay.style.cursor='grabbing';
      } else {
        movingNodeId = null;
      }
      dragStart={x,y,nodeId:null,createdStart:false}; hoverEndNodeId=null;
    }
    draw();
  });

  overlay.addEventListener('mousemove', (e)=>{
    const {x,y}=mousePos(e);
    hoverInfo = null;

    if (mode==='draw' && dragStart){
      hoverEndNodeId = nearNodeId(x,y);
      draw();

      // live segment
      ovr.save();
      ovr.lineWidth=2; ovr.setLineDash([6,4]); ovr.strokeStyle='#3a86ff';
      ovr.beginPath(); ovr.moveTo(dragStart.x,dragStart.y); ovr.lineTo(x,y); ovr.stroke();
      if (dragStart.existingStart) highlightNode(ovr, nodeById(dragStart.nodeId));
      if (hoverEndNodeId)        highlightNode(ovr, nodeById(hoverEndNodeId));

      // live coordinate tag at current mouse (candidate end node)
      drawCoordTag(ovr, x, y, `(${x.toFixed(1)}, ${y.toFixed(1)})`);
      ovr.restore();
      return;
    }

    draw(); // clears overlay

    // Selection + hover info
    const mid=nearMemberId(x,y,6);
    const nid=nearNodeId(x,y,8);

    if (mode==='select'){
      if (movingNodeId!==null){
        const n = nodeById(movingNodeId);
        n.x = x - moveOffset.dx;
        n.y = y - moveOffset.dy;
        lastSolution = null;
        draw();
        return;
      }
      if (mid){
        const m=memberById(mid), a=nodeById(m.n1), b=nodeById(m.n2);
        ovr.save(); ovr.lineWidth=4; ovr.strokeStyle='#ff006e';
        ovr.beginPath(); ovr.moveTo(a.x,a.y); ovr.lineTo(b.x,b.y); ovr.stroke(); ovr.restore();
        overlay.style.cursor='pointer';

        // Hover tooltip for force & stress (if solved)
        if (lastSolution){
          const info = getMemberHoverInfo(mid, {x,y});
          if (info){
            hoverInfo = { x:x+12, y:y-12, lines:info };
          }
        }
      } else if (nid){
        const n=nodeById(nid);
        ovr.save(); ovr.fillStyle='rgba(16,185,129,0.22)';
        ovr.beginPath(); ovr.arc(n.x,n.y,10,0,Math.PI*2); ovr.fill(); ovr.restore();
        overlay.style.cursor='pointer';

        // Show node coordinate tag on hover
        drawCoordTag(ovr, n.x+12, n.y-12, `(${n.x.toFixed(1)}, ${n.y.toFixed(1)})`);
      } else {
        overlay.style.cursor='pointer';
      }
    }

    if (hoverInfo) drawHoverTooltip(ovr, hoverInfo);
  });

  overlay.addEventListener('mouseup', (e)=>{
    hoverInfo = null;
    const {x,y}=mousePos(e);
    if (mode==='draw' && dragStart){
      let nid=nearNodeId(x,y);
      let endNode;
      if (nid){ endNode=nodeById(nid); }
      else { const id=addNode(x,y); endNode=nodeById(id); }
      if (endNode.id===dragStart.nodeId){
        if (dragStart.createdStart){ nodes.pop(); }
        dragStart=null; hoverEndNodeId=null; refreshLists(); draw(); return;
      }
      const mid=addMember(dragStart.nodeId, endNode.id);
      dragStart=null; hoverEndNodeId=null; refreshLists(); draw();
      if (mid) editMember(memberById(mid));
      return;
    }
    if (mode==='select'){
      const mid=nearMemberId(x,y,6);
      const nid=nearNodeId(x,y,8);

      if (movingNodeId!==null){
        movingNodeId = null;
        overlay.style.cursor='pointer';
        draw();
        return;
      }

      if (viewMode==='stresspanel' && mid){
        selectedMemberId = mid;
        plotStressPanel();
        return;
      }

      if (nid){
        selectedNodeId = nid;
        selectedMemberForDelete = null;
        draw();
        return;
      }
      if (mid){
        selectedMemberForDelete = mid;
        selectedNodeId = null;
        draw();
        return;
      }

      selectedNodeId = null;
      selectedMemberForDelete = null;
      draw();
    }
  });

  overlay.addEventListener('dblclick', (e)=>{
    if (mode!=='select') return;
    const {x,y}=mousePos(e);
    const nid=nearNodeId(x,y,8);
    const mid=nearMemberId(x,y,6);
    if (nid){ editNode(nodeById(nid)); draw(); return; }
    if (mid){ editMember(memberById(mid)); draw(); return; }
  });

  document.addEventListener('keydown', (e)=>{
    if (mode!=='select') return;
    if (e.key==='Delete' || e.key==='Backspace'){
      if (selectedNodeId){
        deleteNodeWithMembers(selectedNodeId);
        selectedNodeId = null;
        e.preventDefault();
      } else if (selectedMemberForDelete){
        deleteMember(selectedMemberForDelete);
        selectedMemberForDelete = null;
        e.preventDefault();
      }
    }
  });

  function mousePos(e){ const r=overlay.getBoundingClientRect(); return { x:e.clientX-r.left, y:e.clientY-r.top }; }

  // ===== Editors =====
  function editNode(node){
    const bcOptions = [
      {value:'free',     text:'Free (no restraints)'},
      {value:'simple',   text:'Pinned: u=0, v=0'},
      {value:'rollerX',  text:'Roller-X: u=0, v free'},
      {value:'rollerY',  text:'Roller-Y: v=0, u free'},
      {value:'fixed',    text:'Fixed (truss): u=0, v=0'},
    ];
    const html = `
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
        <label style="grid-column:1/3; font-weight:600;">Boundary Condition</label>
        <select id="bc" class="swal2-select" style="grid-column:1/3;">
          ${bcOptions.map(o=>`<option value="${o.value}" ${node.bc===o.value?'selected':''}>${o.text}</option>`).join('')}
        </select>
        <div style="grid-column:1/3; display:flex; gap:10px; align-items:center;">
          <canvas id="bcGlyph" width="180" height="60" style="border:1px dashed #ddd; border-radius:6px;"></canvas>
          <span class="hint">Global axes</span>
        </div>
        <label style="grid-column:1/3; font-weight:600; margin-top:6px;">Nodal Loads</label>
        <label>Fx</label><input id="Fx" class="swal2-input" type="number" step="any" value="${node.Fx}">
        <label>Fy</label><input id="Fy" class="swal2-input" type="number" step="any" value="${node.Fy}">
        <label style="grid-column:1/3; font-weight:600; margin-top:6px;">Translational Springs</label>
        <label>Kx</label><input id="Kx" class="swal2-input" type="number" step="any" value="${node.Kx}">
        <label>Ky</label><input id="Ky" class="swal2-input" type="number" step="any" value="${node.Ky}">
      </div>`;
    Swal.fire({
      title:`Node ${node.id}`,
      html, showCancelButton:true, confirmButtonText:'Save',
      didOpen:()=>{
        const g=document.getElementById('bcGlyph').getContext('2d');
        const sel=document.getElementById('bc');
        drawBCGlyph(g, sel.value);
        sel.addEventListener('change', ev => drawBCGlyph(g, ev.target.value));
      },
      preConfirm:()=>{
        const v = id => parseFloat(document.getElementById(id).value)||0;
        return { bc:document.getElementById('bc').value, Fx:v('Fx'), Fy:v('Fy'), Kx:v('Kx'), Ky:v('Ky') };
      }
    }).then(res=>{ if (res.isConfirmed){ Object.assign(node,res.value); refreshLists(); draw(); }});
  }

  function editMember(m){
    const html = `
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:center;">
        <label>Label</label><input id="label" class="swal2-input" type="text" value="${m.label||''}">
        <div style="grid-column:1/3; height:1px; background:#ececec; margin:6px 0;"></div>

        <label>E</label><input id="E" class="swal2-input" type="number" step="any" value="${m.E}">
        <label>wd (density)</label><input id="wd" class="swal2-input" type="number" step="any" value="${m.wd}">
        <label>A</label><input id="A" class="swal2-input" type="number" step="any" value="${m.A}">

        <!-- Optional bending props for q-superposition -->
        <label>I (for q superposition)</label><input id="I" class="swal2-input" type="number" step="any" value="${m.I||0}">
        <label>S (section modulus)</label><input id="S" class="swal2-input" type="number" step="any" value="${m.S||0}">
        <div class="hint" style="grid-column:1/3;">If S is blank but I and c are known, σ<sub>b</sub>=M/S with S=I/c. If neither present, bending is skipped.</div>

        <div style="grid-column:1/3; height:1px; background:#ececec; margin:6px 0;"></div>

        <label>qix</label><input id="qix" class="swal2-input" type="number" step="any" value="${m.qix}">
        <label>qjx</label><input id="qjx" class="swal2-input" type="number" step="any" value="${m.qjx}">
        <label>qiy</label><input id="qiy" class="swal2-input" type="number" step="any" value="${m.qiy}">
        <label>qjy</label><input id="qjy" class="swal2-input" type="number" step="any" value="${m.qjy}">
      </div>`;
    Swal.fire({
      title:`Member ${m.id}`,
      html, showCancelButton:true, confirmButtonText:'Save',
      preConfirm:()=>{
        const v=id=>parseFloat(document.getElementById(id)?.value)||0;
        const s=id=>document.getElementById(id)?.value||'';
        let I=v('I'), S=v('S');
        let c = (m.c||0);
        if ((S<=0) && (I>0 && c>0)) S = I/c;
        return {
          label: s('label').trim(),
          E:v('E'), wd:v('wd'),
          A: v('A')||0, I: I||0, S: S||0, c: c||0,
          qix:v('qix'), qjx:v('qjx'), qiy:v('qiy'), qjy:v('qjy')
        };
      }
    }).then(res=>{ if (res.isConfirmed){ Object.assign(m,res.value); refreshLists(); draw(); }});
  }

  // === Support glyphs (canvas + editor) ===
  function drawBCGlyph(g, bc){
    g.clearRect(0,0,g.canvas.width,g.canvas.height);
    g.save();
    g.translate(20, g.canvas.height-20);
    g.strokeStyle='#aaa'; g.lineWidth=1;
    g.beginPath(); g.moveTo(0,0); g.lineTo(140,0); g.stroke();
    g.beginPath(); g.moveTo(0,0); g.lineTo(0,-40); g.stroke();

    if (bc==='fixed'){
      g.lineWidth=6; g.strokeStyle='#222';
      g.beginPath(); g.moveTo(0,0); g.lineTo(0,-30); g.stroke();
      g.lineWidth=1; g.strokeStyle='#666';
      for (let k=-14; k<=14; k+=7){ g.beginPath(); g.moveTo(0, k); g.lineTo(-8, k-6); g.stroke(); }
    } else if (bc==='simple'){
      g.fillStyle='#222';
      g.beginPath(); g.moveTo(0,0); g.lineTo(-12,12); g.lineTo(12,12); g.closePath(); g.fill();
      g.fillRect(-16,12,32,3);
    } else if (bc==='rollerX'){
      g.fillStyle='#222'; g.fillRect(-2, -4, 4, 8); g.fillRect(10, 2, 26, 3);
    } else if (bc==='rollerY'){
      g.fillStyle='#222'; g.fillRect(-2, -4, 4, 8); g.fillRect(-18, 12, 3, 26);
    }
    g.restore();
  }

  // ===== Draw =====
  function draw(){
    ctx.clearRect(0,0,base.width,base.height);
    ovr.clearRect(0,0,overlay.width,overlay.height);
    drawGrid(ctx);

    const qScale = computeQScale();

    ctx.save();
    ctx.lineWidth=2; ctx.strokeStyle='#222';
    ctx.font='12px system-ui'; ctx.fillStyle='#000';

    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();

      const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
      ctx.fillText(m.label||`M${m.id}`, mx+4, my-6);

      if (viewMode==='geom' || viewMode==='def'){
        drawDistributedLoads(ctx, m, qScale);
      }
    }
    ctx.restore();

    for (const n of nodes){
      drawNodeBC(ctx, n);
      drawNodeLoadsAndSprings(ctx, n);

      // node dot
      ctx.save(); ctx.fillStyle='#1d4ed8';
      ctx.beginPath(); ctx.arc(n.x,n.y,4,0,Math.PI*2); ctx.fill(); ctx.restore();

      // coordinate tag next to node
      drawCoordTag(ctx, n.x+10, n.y-12, `(${n.x.toFixed(1)}, ${n.y.toFixed(1)})`);
    }

    // Support reactions (if available)
    if (lastSolution && lastSolution.reactionsByNode){
      drawReactions(ctx, lastSolution.reactionsByNode);
    }

    if (viewMode==='def' && lastSolution){
      let scale = parseFloat(document.getElementById('defScale').value)||1;
      if (anim.scaleOverride != null) scale = anim.scaleOverride;

      const addQL = lastSolution.qAdd;
      ctx.save();
      ctx.lineWidth=2; ctx.strokeStyle='#e11d48';
      for (const poly of lastSolution.sublines){
        ctx.beginPath();
        for (let k=0;k<poly.length;k++){
          const p=poly[k];
          let du = scale*p.u, dv = scale*p.v;

          if (addQL && addQL.perMember[p.memId]){
            const qinfo = addQL.perMember[p.memId];
            const yss = qinfo.yLocs[p.subIndex] || 0;
            du -= scale * qinfo.s * yss;  // local y -> global
            dv += scale * qinfo.c * yss;
          }

          const xc = p.x_up + du;              // +u to the right
          const yc = yCanvas(p.y_up + dv);
          if (k===0) ctx.moveTo(xc, yc); else ctx.lineTo(xc, yc);
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    drawSelection();

    // Hover tooltip (if set by mousemove)
    if (hoverInfo) drawHoverTooltip(ovr, hoverInfo);
  }

  function drawReactions(g, reactionsByNode){
    g.save();
    g.strokeStyle='#059669'; g.fillStyle='#059669'; g.lineWidth=2;
    g.font='12px system-ui';
    for (const nidStr of Object.keys(reactionsByNode)){
      const nid = parseInt(nidStr,10);
      const n = nodeById(nid); if (!n) continue;
      const {Rx, Ry} = reactionsByNode[nid];

      if (Math.abs(Rx) > 1e-12){
        const dir = Math.sign(Rx) || 1;
        const len = 20 + 16*Math.min(1, Math.abs(Rx)/ (Math.abs(Rx)+1e-9));
        drawArrow(g, n.x, n.y, n.x + dir*len, n.y);
        g.fillText(`Rx=${round6(Rx)}`, n.x + dir*(len+6), n.y - 6);
      }
      if (Math.abs(Ry) > 1e-12){
        const up = Ry>0; const len = 20 + 16*Math.min(1, Math.abs(Ry)/ (Math.abs(Ry)+1e-9));
        drawArrow(g, n.x, n.y, n.x, n.y + (up ? -len : +len));
        g.fillText(`Ry=${round6(Ry)}`, n.x + 6, n.y + (up ? -len-6 : len+14));
      }
    }
    g.restore();
  }

  function drawNodeBC(g, node){
    const {x,y,bc}=node;
    g.save(); g.strokeStyle='#000'; g.fillStyle='#000';
    if (bc==='fixed'){
      g.lineWidth=6; g.beginPath(); g.moveTo(x-10, y-16); g.lineTo(x-10, y+16); g.stroke();
      g.lineWidth=1; g.strokeStyle='#666';
      for (let k=-14; k<=14; k+=7){ g.beginPath(); g.moveTo(x-10, y+k); g.lineTo(x-18, y+k-6); g.stroke(); }
    } else if (bc==='simple'){
      g.beginPath(); g.moveTo(x, y+8); g.lineTo(x-10, y+18); g.lineTo(x+10, y+18); g.closePath(); g.fill();
      g.fillRect(x-14, y+18, 28, 3);
    } else if (bc==='rollerX'){
      g.beginPath(); g.moveTo(x-6,y); g.lineTo(x+6,y); g.stroke();
      g.fillRect(x+10, y+2, 26, 3);
    } else if (bc==='rollerY'){
      g.beginPath(); g.moveTo(x,y-6); g.lineTo(x,y+6); g.stroke();
      g.fillRect(x-18, y+12, 3, 26);
    }
    g.restore();
  }

  function drawSelection(){
    if (selectedNodeId){
      const n = nodeById(selectedNodeId);
      if (n){
        ovr.save();
        ovr.lineWidth=3; ovr.strokeStyle='#10b981';
        ovr.beginPath(); ovr.arc(n.x,n.y,12,0,Math.PI*2); ovr.stroke();
        ovr.restore();
      }
    }
    if (selectedMemberForDelete){
      const m = memberById(selectedMemberForDelete);
      if (m){
        const a=nodeById(m.n1), b=nodeById(m.n2);
        ovr.save(); ovr.lineWidth=4; ovr.strokeStyle='#f59e0b';
        ovr.beginPath(); ovr.moveTo(a.x,a.y); ovr.lineTo(b.x,b.y); ovr.stroke();
        ovr.restore();
      }
    }
  }

  function drawGrid(g){
    const step=40;
    g.save();
    g.lineWidth=1; g.strokeStyle='#eee'; g.fillStyle='#999';
    for (let x=0; x<=base.width; x+=step){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,base.height); g.stroke(); if (x%160===0) g.fillText(x, x+2, 12); }
    for (let y=0; y<=base.height; y+=step){ g.beginPath(); g.moveTo(0,y); g.lineTo(base.width,y); g.stroke(); if (y%160===0) g.fillText(y, 2, y-2); }
    g.restore();
  }

  function drawNodeLoadsAndSprings(g, node){
    if (viewMode==='stresspanel') return;
    const {x,y,Fx,Fy,Kx,Ky}=node;
    g.save();
    g.strokeStyle='#db2777'; g.fillStyle='#db2777'; g.lineWidth=2;
    if (Fx!==0){ const sign=Fx>0?1:-1, L=26*sign; drawArrow(g,x,y,x+L,y); g.fillText('Fx', x+L+(sign>0?6:-18), y-6); }
    if (Fy!==0){ const sign=Fy>0?-1:1, L=26*sign; drawArrow(g,x,y,x,y+L); g.fillText('Fy', x+6, y+L+(sign<0?-8:14)); }
    g.strokeStyle='#0f766e'; g.fillStyle='#0f766e'; g.lineWidth=2;
    if (Kx>0){ drawSpringX(g, x+16, y, 18, 6); g.fillText('Kx', x+40, y-6); }
    if (Ky>0){ drawSpringY(g, x, y+16, 18, 6); g.fillText('Ky', x+6, y+42); }
    g.restore();
  }

  // q-load graphics
  function computeQScale(){
    let maxQx=0, maxQy=0;
    for (const m of members){
      maxQx = Math.max(maxQx, Math.abs(m.qix||0), Math.abs(m.qjx||0));
      maxQy = Math.max(maxQy, Math.abs(m.qiy||0), Math.abs(m.qjy||0));
    }
    return { maxQx: maxQx || 1, maxQy: maxQy || 1, lenX:28, lenY:28 };
  }
  function drawDistributedLoads(g, m, qScale){
    const a=nodeById(m.n1), b=nodeById(m.n2);
    const dx=b.x-a.x, dy=b.y-a.y;
    const markers = 12;
    // qx
    for (let k=0;k<=markers;k++){
      const t=k/markers, x=a.x+dx*t, y=a.y+dy*t;
      const qx = (m.qix||0) + ((m.qjx||0) - (m.qix||0))*t;
      if (Math.abs(qx)>1e-12){
        const dir = Math.sign(qx)||1, len=Math.max(8, Math.abs(qx)/qScale.maxQx*qScale.lenX);
        drawArrow(g, x, y, x + dir*len, y);
        if (k===Math.floor(markers/2)) g.fillText('qx', x + dir*len + (dir>0?6:-18), y-6);
      }
    }
    // qy
    for (let k=0;k<=markers;k++){
      const t=k/markers, x=a.x+dx*t, y=a.y+dy*t;
      const qy = (m.qiy||0) + ((m.qjy||0) - (m.qiy||0))*t;
      if (Math.abs(qy)>1e-12){
        const up=qy>0, len=Math.max(8, Math.abs(qy)/qScale.maxQy*qScale.lenY);
        drawArrow(g, x, y, x, y + (up ? -len : +len));
        if (k===Math.floor(markers/2)) g.fillText('qy', x+6, y + (up ? -len-6 : len+14));
      }
    }
  }

  // ===== SOLVER (TRUSS) + q-load superposition =====
  function solveTruss(){
    const DIV = Math.max(1, Math.min(50, (parseInt(document.getElementById('divCount').value)||10)));
    try {
      const build = buildAnalysisModelTruss(DIV);
      const {N, dofMap, anodes, F, K} = build;

      // sanity: at least one support
      const supportCount = nodes.reduce((n,nd)=> n + ((nd.bc!=='free')?1:0), 0);
      if (supportCount === 0) { Swal.fire('No supports','Add at least one support (simple/roller).','error'); return; }

      // add node springs
      for (const n of nodes){
        const base = dofMap.primary[n.id]; if (base===undefined) continue;
        if (n.Kx>0) K[base+0][base+0] += n.Kx;
        if (n.Ky>0) K[base+1][base+1] += n.Ky;
      }
      // add nodal loads
      for (const n of nodes){
        const b = dofMap.primary[n.id]; if (b===undefined) continue;
        F[b+0] += n.Fx; F[b+1] += n.Fy;
      }

      // boundary conditions
      const constrained = new Set();
      for (const n of nodes){
        const b = dofMap.primary[n.id]; if (b===undefined) continue;
        if (n.bc==='fixed' || n.bc==='simple'){
          constrained.add(b+0); constrained.add(b+1);
        } else if (n.bc==='rollerX'){
          constrained.add(b+0);
        } else if (n.bc==='rollerY'){
          constrained.add(b+1);
        }
      }
      const allIdx = [...Array(N).keys()];
      const freeIdx = allIdx.filter(i => !constrained.has(i));
      if (freeIdx.length===0){ console.warn('All DOFs constrained', {dofMap,nodes}); Swal.fire('No free DOFs','All translational DOFs are restrained.','error'); return; }

      const Kff = matPick(K, freeIdx, freeIdx);
      const Ff  = vecPick(F, freeIdx);
      let Uf;
      try { Uf = numeric.solve(Kff, Ff); } catch { throw new Error('singular'); }
      if (Uf.some(v => !isFinite(v))) throw new Error('singular');

      const U = Array(N).fill(0);
      freeIdx.forEach((gi, k) => { U[gi] = Uf[k]; });

      const KU = numeric.dot(K, U);
      const R = KU.map((v,i)=>v - F[i]);

      // Map reactions to nodes (only restrained DOFs matter)
      const reactionsByNode = {};
      for (const n of nodes){
        const b = dofMap.primary[n.id];
        let Rx = 0, Ry = 0;
        if (constrained.has(b+0)) Rx = R[b+0];
        if (constrained.has(b+1)) Ry = R[b+1];
        reactionsByNode[n.id] = {Rx, Ry};
      }

      // ----- build sampled polylines & axial forces (no interior DOFs) -----
      const sublines = [];
      const axial    = {};
      const samplesByMember = {};

      for (const m of members){
        const g = build.geom[m.id]; if (!g) continue;

        const bi = build.dofMap.analysis[g.i];
        const bj = build.dofMap.analysis[g.j];

        const ui = {u:U[bi+0], v:U[bi+1]};
        const uj = {u:U[bj+0], v:U[bj+1]};

        // constant axial force in a 2D bar
        const dux = (U[bj+0]-U[bi+0]), duy = (U[bj+1]-U[bi+1]);
        const Nbar = (m.E||0)*(m.A||0)/g.L * ( g.c*dux + g.s*duy ); // + tension
        axial[m.id] = { N:[Nbar,Nbar], cnt:[1,1] };

        // sampled polyline (DIV+2 points including ends)
        const poly = [];
        const S = build.DIV;
        const pi = build.anodes[g.i], pj = build.anodes[g.j];

        samplesByMember[m.id] = [];
        for (let k=0; k<=S+1; k++){
          const t = k/(S+1);
          const x_up = pi.x_up + t*(pj.x_up - pi.x_up);
          const y_up = pi.y_up + t*(pj.y_up - pi.y_up);
          const u = ui.u*(1-t) + uj.u*t;
          const v = ui.v*(1-t) + uj.v*t;

          poly.push({ memId:m.id, subIndex:k, x_up, y_up, u, v });
          samplesByMember[m.id].push({t, x: t*g.L, c:g.c, s:g.s});
        }
        sublines.push(poly);
      }

      // ----- q-load simply-supported superposition & stresses -----
      const qAdd = { perMember:{}, yLocsByMember:{} };
      const stress = {};

      for (const m of members){
        const g = build.geom[m.id]; if (!g) continue;
        const S = build.DIV + 2;
        const smp = samplesByMember[m.id];

        const qx_avg = 0.5*((m.qix||0)+(m.qjx||0));
        const qy_avg = 0.5*((m.qiy||0)+(m.qjy||0));
        const sw     = (m.wd||0)*(m.A||0);
        const Qx = qx_avg, Qy = qy_avg - sw;
        const w = -g.s*Qx + g.c*Qy;      // local transverse for SS beam

        const E=m.E||0, I=m.I||0, useBend=(E>0&&I>0);
        const yLocs=[], xs=[];
        for (let k=0; k<S; k++){
          const x = smp[k].x; xs.push(x);
          yLocs.push(
            useBend ? (w * x * (g.L*g.L*g.L - 2*g.L*x*x + x*x*x)) / (24*E*I) : 0
          );
        }
        qAdd.perMember[m.id] = { yLocs, xs, c:g.c, s:g.s };
        qAdd.yLocsByMember[m.id] = yLocs;

        // stresses (axial + optional bending from SS)
        const A=m.A||0;
        const Smod = (m.S>0)? m.S : ((m.I>0 && m.c>0)? (m.I/m.c) : 0);
        const sL=[], sR=[], pts=[];
        const pi = build.anodes[g.i], pj = build.anodes[g.j];

        for (let k=0; k<S; k++){
          const t = smp[k].t;
          const x_up = pi.x_up + t*(pj.x_up - pi.x_up);
          const y_up = pi.y_up + t*(pj.y_up - pi.y_up);
          const Na = axial[m.id].N[0];        // constant along a bar
          const sigAx = (A>0)? (Na/A) : 0;

          let sigB = 0;
          if (useBend && Smod>0){
            const x = xs[k];
            const Ra = w * g.L / 2;
            const Mx = Ra * x - w * x*x / 2;
            sigB = Mx / Smod;
          }
          sL.push(sigAx - sigB);
          sR.push(sigAx + sigB);
          pts.push({x_up, y_up});
        }
        stress[m.id] = { pts, sL, sR };
      }

      lastSolution = {
        Ufull:U, dofMap:build.dofMap, anodes:build.anodes,
        sublines, reactions:R, reactionsByNode, axial, stress, qAdd, geom: build.geom
      };

      lastSolution.primaryRes = nodes.map(n=>{
        const b = build.dofMap.primary[n.id];
        return { id:n.id, ux:round6(U[b+0]), uy:round6(U[b+1]) };
      });
      showResults(lastSolution.primaryRes);
      summarizeMemberStresses();

      // auto deflection scale
      const bbox = modelBounds();
      const Lref = Math.max(bbox.w, bbox.h) || 1;
      let maxDisp=0;
      for (const aidStr of Object.keys(lastSolution.anodes)){
        const aid = parseInt(aidStr,10);
        const b = lastSolution.dofMap.analysis[aid];
        const u = lastSolution.Ufull[b+0], v = lastSolution.Ufull[b+1];
        maxDisp = Math.max(maxDisp, Math.hypot(u,v));
      }
      for (const mem of members){
        const yLocs = qAdd.yLocsByMember[mem.id]||[];
        for (const y of yLocs) maxDisp = Math.max(maxDisp, Math.abs(y));
      }
      const defScaleAuto = (maxDisp>0) ? (0.20*Lref/maxDisp) : 1;
      document.getElementById('defScale').value = +defScaleAuto.toFixed(4);

      if (viewMode==='stresspanel') plotStressPanel();
      draw();
    } catch (err){
      console.error(err);
      Swal.fire({
        icon:'error',
        title:'Solve failed',
        html:`<div style="text-align:left">
          <div><b>Likely causes</b></div>
          <ul style="margin:6px 0 0 18px;">
            <li>Under-constrained truss (need enough supports).</li>
            <li>Member has zero length or missing E/A.</li>
          </ul>
        </div>`
      });
    }
  }

  // ===== Build model (TRUSS) – primary-node DOFs only =====
  function buildAnalysisModelTruss(DIV){
    const anodes = {};
    const dofMap = { primary:{}, analysis:{} };
    let aNextId = 1;

    // analysis nodes == primary nodes only (2 DOF/node)
    for (const n of nodes){
      const id=aNextId++;
      anodes[id] = { x_up:n.x, y_up:yUp(n.y), primary:n.id };
      dofMap.primary[n.id] = (id-1)*2;
      dofMap.analysis[id] = (id-1)*2;
    }

    // one bar per member
    const elems = [];
    const geom  = {};
    for (const m of members){
      const ni = getAnalysisIdForPrimary(m.n1, anodes);
      const nj = getAnalysisIdForPrimary(m.n2, anodes);
      const pi = anodes[ni], pj = anodes[nj];
      const dx = pj.x_up - pi.x_up, dy = pj.y_up - pi.y_up;
      const L = Math.hypot(dx,dy); if (L<1e-9) continue;
      const c = dx/L, s = dy/L;

      elems.push({ i:ni, j:nj, L, c, s, E:m.E||0, A:m.A||0, memId:m.id });
      geom[m.id] = { i:ni, j:nj, L, c, s };
    }

    const N = Object.keys(anodes).length * 2;
    const K = zeros(N,N);
    const F = zeros(N);

    // assemble (axial only)
    for (const el of elems){
      const k = (el.E*el.A)/el.L;
      const {c,s} = el;
      const kG = [
        [ k*c*c,   k*c*s,  -k*c*c,  -k*c*s ],
        [ k*c*s,   k*s*s,  -k*c*s,  -k*s*s ],
        [-k*c*c,  -k*c*s,   k*c*c,   k*c*s ],
        [-k*c*s,  -k*s*s,   k*c*s,   k*s*s ]
      ];
      const ib = dofMap.analysis[el.i], jb = dofMap.analysis[el.j];
      addToGlobalVar(K, kG, [ib+0, ib+1, jb+0, jb+1]);
    }

    return { N, dofMap, anodes, F, K, elems, geom, DIV: Math.max(1, Math.min(50, DIV|0)) };
  }

  // ===== Stress Panel =====
  function plotStressPanel(){
    if (stressBlock.style.display==='none') return;
    resizeStressCanvas();
    const w=stressCanvas.width, h=stressCanvas.height;
    spx.clearRect(0,0,w,h);
    if (!lastSolution || !selectedMemberId){
      spx.save(); spx.fillStyle='#999'; spx.fillText('Solve and click a member to plot stresses.', 10, 20); spx.restore(); return;
    }
    const st = lastSolution.stress[selectedMemberId];
    if (!st){ spx.fillText('Selected member has no stress data.', 10, 20); return; }

    const xs=[0]; let Lsum=0;
    for (let i=1;i<st.pts.length;i++){
      const x0=st.pts[i-1].x_up, y0=st.pts[i-1].y_up, x1=st.pts[i].x_up, y1=st.pts[i].y_up;
      Lsum += Math.hypot(x1-x0, y1-y0);
      xs.push(Lsum);
    }
    const SLp = st.sL.map(v => -v);
    const SRp = st.sR.map(v => -v);
    const minS = Math.min(...SLp, ...SRp), maxS=Math.max(...SLp,...SRp);
    const left=45, right=15, top=15, bot=30;

    spx.save();
    spx.strokeStyle='#444'; spx.lineWidth=1;
    spx.beginPath(); spx.moveTo(left, top); spx.lineTo(left, h-bot); spx.lineTo(w-right, h-bot); spx.stroke();
    spx.fillStyle='#333'; spx.fillText('σ', 8, top+10); spx.fillText('x', w-right-10, h-bot+18);

    const xMap = x => left + (w-left-right)*(x/Lsum || 0);
    const yMap = s => (h-bot) - (h-top-bot) * ((s - minS) / (maxS - minS || 1));

    const y0 = yMap(0); spx.strokeStyle='#ddd'; spx.setLineDash([4,4]);
    spx.beginPath(); spx.moveTo(left, y0); spx.lineTo(w-right, y0); spx.stroke(); spx.setLineDash([]);

    spx.strokeStyle='#ef4444'; spx.beginPath();
    for (let i=0;i<xs.length;i++){ const x=xMap(xs[i]), y=yMap(SLp[i]); if (i===0) spx.moveTo(x,y); else spx.lineTo(x,y); } spx.stroke();
    spx.strokeStyle='#3b82f6'; spx.beginPath();
    for (let i=0;i<xs.length;i++){ const x=xMap(xs[i]), y=yMap(SRp[i]); if (i===0) spx.moveTo(x,y); else spx.lineTo(x,y); } spx.stroke();

    spx.fillStyle='#666';
    spx.fillText(`${minS.toFixed(3)}`, 6, yMap(minS)+4);
    spx.fillText(`${maxS.toFixed(3)}`, 6, yMap(maxS)+4);
    spx.fillText(`Member ${selectedMemberId}`, left+6, top+12);
    spx.restore();
  }

  // ===== Member stress summary (sidebar) =====
  function summarizeMemberStresses(){
    if (!lastSolution || !lastSolution.stress) return;
    const items = [];
    for (const memId of Object.keys(lastSolution.stress)){
      const st = lastSolution.stress[memId];
      if (!st) continue;
      const all = st.sL.concat(st.sR);
      const sMin = Math.min(...all);
      const sMax = Math.max(...all);
      items.push(`<div>Member ${memId}: σmin=${sMin.toFixed(3)}, σmax=${sMax.toFixed(3)}</div>`);
    }
    const box = document.getElementById('resultList');
    box.insertAdjacentHTML('beforeend',
      `<div style="margin-top:6px;border-top:1px dashed #ddd;padding-top:6px;">
         <strong>Member Stress Summary</strong>${items.join('')||'<div class="hint">No members.</div>'}
       </div>`);
  }

  // ===== Hover info helpers =====
  function getMemberHoverInfo(memId, Pcanvas){
    if (!lastSolution) return null;
    const m = memberById(memId); if (!m) return null;
    const a=nodeById(m.n1), b=nodeById(m.n2);
    const tCanvas = pointToSegmentProjectionT(Pcanvas, a, b);
    const st = lastSolution.stress[memId]; if (!st) return null;
    const xs=[0]; let Lsum=0;
    for (let i=1;i<st.pts.length;i++){
      const x0=st.pts[i-1].x_up, y0=st.pts[i-1].y_up, x1=st.pts[i].x_up, y1=st.pts[i].y_up;
      Lsum += Math.hypot(x1-x0, y1-y0);
      xs.push(Lsum);
    }
    const pi = lastSolution.anodes[lastSolution.geom[memId].i];
    const pj = lastSolution.anodes[lastSolution.geom[memId].j];
    const Px_up = pi.x_up + tCanvas*(pj.x_up - pi.x_up);
    const Py_up = pi.y_up + tCanvas*(pj.y_up - pi.y_up);
    let bestK=0, bestD=Infinity, run=0;
    for (let k=0;k<st.pts.length;k++){
      const dx = st.pts[k].x_up - Px_up, dy = st.pts[k].y_up - Py_up;
      const d = dx*dx + dy*dy;
      if (d<bestD){ bestD=d; bestK=k; run=xs[k]; }
    }
    const Nbar = (lastSolution.axial[memId]?.N?.[0]) || 0;
    const sL = st.sL[bestK] ?? 0;
    const sR = st.sR[bestK] ?? 0;
    const sense = (Nbar>=0) ? 'tension' : 'compression';
    return [
      `${m.label||`M${memId}`}`,
      `N = ${round6(Nbar)} (${sense})`,
      `x ≈ ${round6(run)} along`,
      `σL = ${round6(sL)}, σR = ${round6(sR)}`
    ];
  }

  // ======= NODE PANEL (editable X/Y) =======
  function refreshLists(){
    // Nodes: editable X/Y inputs that live-update geometry
    nodeList.innerHTML = nodes.map(n =>
      `<div class="node-row">
         <span class="badge">Node ${n.id}</span>
         <input type="number" class="nedit" data-id="${n.id}" data-field="x" step="any" value="${n.x}">
         <input type="number" class="nedit" data-id="${n.id}" data-field="y" step="any" value="${n.y}">
         <button class="ghost" data-del-node="${n.id}" title="Delete node">✖</button>
       </div>`
    ).join('') || '<div class="hint">No nodes yet.</div>';

    memberList.innerHTML = members.map(m =>
      `<div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
         <span>Member ${m.id} [${m.label||''}]: n${m.n1}–n${m.n2} | E=${fmt(m.E)} A=${fmt(m.A)} I=${fmt(m.I)} S=${fmt(m.S)} wd=${fmt(m.wd)} qx=${fmt(m.qix)}→${fmt(m.qjx)} qy=${fmt(m.qiy)}→${fmt(m.qjy)}</span>
         <button class="ghost" data-del-member="${m.id}" title="Delete member">✖</button>
       </div>`
    ).join('') || '<div class="hint">No members yet.</div>';
  }
  const fmt = v => (v===0 || isNaN(v)) ? '0' : String(v);

  // Node panel: delete
  nodeList.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-del-node]');
    if (!btn) return;
    const id = parseInt(btn.getAttribute('data-del-node'),10);
    deleteNodeWithMembers(id);
  });

  // Node panel: live-edit X/Y (input = live update + draw; change = refresh row formatting)
  nodeList.addEventListener('input', (e)=>{
    const inp = e.target.closest('.nedit');
    if (!inp) return;
    const id = parseInt(inp.dataset.id,10);
    const field = inp.dataset.field;
    const n = nodeById(id); if (!n) return;
    const val = parseFloat(inp.value);
    if (!isFinite(val)) return;
    n[field] = val;
    lastSolution = null; // geometry changed
    draw();
  });
  nodeList.addEventListener('change', (e)=>{
    const inp = e.target.closest('.nedit');
    if (!inp) return;
    // On commit, re-render list so numbers are normalized
    refreshLists();
  });

  // ===== Canvas helpers =====
  function drawCoordTag(g, x, y, text){
    const padX = 6, padY = 4;
    g.save();
    g.font='11px system-ui';
    const w = g.measureText(text).width + 2*padX;
    const h = 18;
    const xx = Math.min(Math.max(4, x), g.canvas.width - w - 4);
    const yy = Math.min(Math.max(4, y - h), g.canvas.height - h - 4);
    g.fillStyle='rgba(17,24,39,0.82)';
    g.strokeStyle='rgba(255,255,255,0.15)';
    g.lineWidth=1;
    g.beginPath(); g.rect(xx, yy, w, h); g.fill(); g.stroke();
    g.fillStyle='#fff';
    g.fillText(text, xx + padX, yy + 12);
    g.restore();
  }

  function drawHoverTooltip(g, tip){
    const pad=8, lh=16;
    const w = Math.max(...tip.lines.map(s=>g.measureText(s).width)) + 2*pad;
    const h = tip.lines.length*lh + 2*pad;
    const x = Math.min(Math.max(6, tip.x), g.canvas.width - w - 6);
    const y = Math.min(Math.max(6, tip.y - h), g.canvas.height - h - 6);

    g.save();
    g.fillStyle='rgba(0,0,0,0.75)';
    g.strokeStyle='rgba(255,255,255,0.15)';
    g.lineWidth=1;
    g.beginPath(); g.rect(x,y,w,h); g.fill(); g.stroke();

    g.fillStyle='#fff'; g.font='12px system-ui';
    for (let i=0;i<tip.lines.length;i++){
      g.fillText(tip.lines[i], x+pad, y+pad + (i+0.85)*lh);
    }
    g.restore();
  }

  // ===== Math helpers =====
  function addToGlobalVar(K, ke, map){
    for (let r=0;r<map.length;r++){
      const R=map[r];
      for (let c=0;c<map.length;c++){
        const C=map[c];
        K[R][C] += ke[r][c];
      }
    }
  }
  function matPick(A, rows, cols){ const M=rows.length,N=cols.length,out=new Array(M); for(let i=0;i<M;i++){ out[i]=new Array(N); for (let j=0;j<N;j++) out[i][j]=A[rows[i]][cols[j]]; } return out; }
  function vecPick(v, rows){ return rows.map(i=>v[i]); }
  function getAnalysisIdForPrimary(pid, anodes){ for (const [aid,obj] of Object.entries(anodes)){ if (obj.primary===pid) return parseInt(aid,10); } return null; }
  function zeros(n,m){ if (m===undefined){ const v=new Array(n); for (let i=0;i<n;i++) v[i]=0; return v; } const A=new Array(n); for (let i=0;i<n;i++){ A[i]=new Array(m); for (let j=0;j<m;j++) A[i][j]=0; } return A; }
  const round6 = x => Math.abs(x)<1e-12 ? 0 : Math.round(x*1e6)/1e6;

  function modelBounds(){
    if (nodes.length===0) return {x0:0,y0:0,w:1,h:1};
    let minx=+Infinity, miny=+Infinity, maxx=-Infinity, maxy=-Infinity;
    for (const n of nodes){ minx=Math.min(minx,n.x); maxx=Math.max(maxx,n.x); miny=Math.min(miny,n.y); maxy=Math.max(maxy,n.y); }
    return {x0:minx, y0:miny, w:(maxx-minx)||1, h:(maxy-miny)||1};
  }

  // drawing helpers
  function drawArrow(g, x1,y1, x2,y2){
    g.beginPath(); g.moveTo(x1,y1); g.lineTo(x2,y2); g.stroke();
    const ang=Math.atan2(y2-y1, x2-x1), ah=7;
    g.beginPath();
    g.moveTo(x2,y2);
    g.lineTo(x2 - ah*Math.cos(ang - Math.PI/6), y2 - ah*Math.sin(ang - Math.PI/6));
    g.lineTo(x2 - ah*Math.cos(ang + Math.PI/6), y2 - ah*Math.sin(ang + Math.PI/6));
    g.closePath(); g.fill();
  }
  function drawSpringX(g, x,y, len=20, amp=5){
    const n=5, dx=len/(n*2);
    g.beginPath(); g.moveTo(x,y);
    for (let i=0;i<n;i++){ g.lineTo(x+dx*(2*i+1), y-amp); g.lineTo(x+dx*(2*i+2), y+amp); }
    g.stroke();
  }
  function drawSpringY(g, x,y, len=20, amp=5){
    const n=5, dy=len/(n*2);
    g.beginPath(); g.moveTo(x,y);
    for (let i=0;i<n;i++){ g.lineTo(x-amp, y+dy*(2*i+1)); g.lineTo(x+amp, y+dy*(2*i+2)); }
    g.stroke();
  }
  function highlightNode(g, n){
    if (!n) return;
    g.save();
    g.lineWidth=3; g.strokeStyle='#10b981';
    g.beginPath(); g.arc(n.x,n.y,10,0,Math.PI*2); g.stroke();
    g.restore();
  }

  // ===== Lists & Results =====
  function showResults(primaryRes){
    resultList.innerHTML = primaryRes.map(r =>
      `<div>Node ${r.id}: ux=${r.ux}, uy=${r.uy}</div>`
    ).join('') || '<div class="hint">Solve to see displacements.</div>';
  }

  function resizeStressCanvas(){
    stressCanvas.style.width = '100%';
    const w = Math.max(200, stressCanvas.parentElement.clientWidth);
    const h = 260;
    stressCanvas.width = w;
    stressCanvas.height = h;
  }
  function toggleStressPanel(show){
    stressBlock.style.display = show ? 'block' : 'none';
    document.getElementById('stressPanelHint').style.display = show ? 'block' : 'none';
    if (show) resizeStressCanvas();
  }

  // ===== Kickoff =====
  setActiveGroup(modeBtns,'btnDraw');
  setActiveGroup(viewBtns,'viewGeom');
  refreshLists();
  draw();
})();
</script>
</body>
</html>

